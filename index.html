<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Tracking</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #06080d;
            color: #e2e8f0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            height: 100dvh;
            -webkit-font-smoothing: antialiased;
        }

        /* ── Loading ── */
        #loading {
            position: fixed; inset: 0;
            background: #06080d;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 9999;
            transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .loader-ring {
            width: 56px; height: 56px;
            border: 3px solid rgba(96,165,250,0.12);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading h2 { margin-top: 24px; font-size: 18px; font-weight: 500; color: #94a3b8; }
        #load-step { margin-top: 8px; font-size: 13px; color: #475569; }

        /* ── Canvas ── */
        #three-canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }

        /* ── Glass panels ── */
        .glass {
            background: rgba(10, 15, 28, 0.78);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 14px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        /* ── Webcam PiP ── */
        #webcam-pip {
            position: fixed; bottom: 20px; left: 20px;
            width: 280px; border-radius: 14px; overflow: hidden;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #webcam-pip:hover { transform: scale(1.02); }
        #webcam-pip.minimized { width: 56px; height: 56px; border-radius: 50%; cursor: pointer; }
        #webcam-pip.minimized video,
        #webcam-pip.minimized canvas,
        #webcam-pip.minimized .pip-badge { display: none; }
        #webcam-pip.minimized::after {
            content: '\ud83d\udcf9'; position: absolute; inset: 0;
            display: flex; align-items: center; justify-content: center;
            font-size: 22px; background: rgba(10,15,28,0.85);
        }
        .pip-wrap { position: relative; aspect-ratio: 4/3; background: #111; }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); display: block; }
        #overlay { position: absolute; inset: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        .pip-badge {
            position: absolute; top: 8px; left: 8px;
            background: rgba(0,0,0,0.55); backdrop-filter: blur(8px);
            padding: 4px 10px; border-radius: 20px;
            font-size: 11px; font-weight: 500;
            display: flex; align-items: center; gap: 6px;
        }
        .pip-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
        .pip-dot.on { background: #4ade80; box-shadow: 0 0 8px #4ade80; }
        .pip-dot.off { background: #fbbf24; box-shadow: 0 0 8px #fbbf24; }
        .pip-dot.err { background: #f87171; box-shadow: 0 0 8px #f87171; }
        .pip-toggle {
            position: absolute; top: 8px; right: 8px;
            width: 26px; height: 26px;
            background: rgba(0,0,0,0.5); border: none; border-radius: 50%;
            color: #94a3b8; cursor: pointer; font-size: 14px;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .pip-toggle:hover { background: rgba(0,0,0,0.8); color: #fff; }

        /* ── Info panel ── */
        #panel-info {
            position: fixed; top: 20px; left: 20px;
            padding: 16px 20px; z-index: 20; min-width: 180px;
        }
        #panel-info h1 { font-size: 15px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        #panel-info h1 .accent { color: #60a5fa; }
        .stat-row { display: flex; justify-content: space-between; align-items: center; padding: 3px 0; font-size: 12px; }
        .stat-label { color: #64748b; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { color: #e2e8f0; font-weight: 600; font-variant-numeric: tabular-nums; }

        /* ── Gesture ── */
        #gesture-display {
            position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%);
            padding: 10px 24px; z-index: 20;
            font-size: 20px; font-weight: 600;
            opacity: 0; transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #gesture-display.show { opacity: 1; }

        /* ── Controls ── */
        #panel-controls {
            position: fixed; bottom: 20px;
            left: 50%; transform: translateX(-50%);
            padding: 8px 10px; display: flex; gap: 6px; z-index: 20;
        }
        .ctrl-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.08);
            color: #64748b; padding: 8px 18px;
            border-radius: 10px; cursor: pointer;
            font-family: inherit; font-size: 12px; font-weight: 500;
            transition: all 0.2s ease; white-space: nowrap;
        }
        .ctrl-btn:hover { color: #e2e8f0; background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.15); }
        .ctrl-btn.active { color: #60a5fa; background: rgba(96,165,250,0.1); border-color: rgba(96,165,250,0.3); }
        .ctrl-sep { width: 1px; background: rgba(255,255,255,0.08); margin: 4px 4px; }

        /* ── Finger legend ── */
        #legend { position: fixed; top: 20px; right: 20px; padding: 14px 18px; z-index: 20; }
        .legend-title { font-size: 11px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.6px; margin-bottom: 10px; }
        .legend-item { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 12px; color: #94a3b8; }
        .legend-dot { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }

        /* ── Depth indicator ── */
        #depth-bar {
            position: fixed; right: 20px; bottom: 80px;
            width: 8px; height: 120px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px; z-index: 20;
            overflow: hidden;
            display: none;
        }
        #depth-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, #60a5fa, #a78bfa);
            border-radius: 4px;
            transition: height 0.15s ease;
        }
        #depth-label {
            position: fixed; right: 34px; bottom: 130px;
            font-size: 10px; color: #64748b;
            text-transform: uppercase; letter-spacing: 0.5px;
            writing-mode: vertical-rl; text-orientation: mixed;
            display: none; z-index: 20;
        }

        @media (max-width: 640px) {
            #webcam-pip { width: 160px; bottom: 12px; left: 12px; }
            #panel-info { top: 12px; left: 12px; padding: 12px 14px; }
            #panel-info h1 { font-size: 13px; }
            #legend { display: none; }
            #panel-controls { bottom: 12px; }
            .ctrl-btn { padding: 6px 12px; font-size: 11px; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader-ring"></div>
        <h2>3D Hand Tracking</h2>
        <p id="load-step">Loading MediaPipe...</p>
    </div>

    <canvas id="three-canvas"></canvas>

    <div id="webcam-pip">
        <div class="pip-wrap">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="overlay"></canvas>
            <div class="pip-badge">
                <div class="pip-dot off" id="pip-dot"></div>
                <span id="pip-status">Starting...</span>
            </div>
            <button class="pip-toggle" id="pip-min" title="Minimize">&minus;</button>
        </div>
    </div>

    <div id="panel-info" class="glass">
        <h1><span class="accent">Hand</span> Analytics</h1>
        <div class="stat-row"><span class="stat-label">FPS</span><span class="stat-value" id="s-fps">--</span></div>
        <div class="stat-row"><span class="stat-label">Hands</span><span class="stat-value" id="s-hands">0</span></div>
        <div class="stat-row"><span class="stat-label">Model</span><span class="stat-value" id="s-model-mode">--</span></div>
        <div class="stat-row"><span class="stat-label">Left Conf</span><span class="stat-value" id="s-left-conf">--</span></div>
        <div class="stat-row"><span class="stat-label">Left Depth</span><span class="stat-value" id="s-left-depth">--</span></div>
        <div class="stat-row"><span class="stat-label">Left Pinch</span><span class="stat-value" id="s-left-pinch">--</span></div>
        <div class="stat-row"><span class="stat-label">Right Conf</span><span class="stat-value" id="s-right-conf">--</span></div>
        <div class="stat-row"><span class="stat-label">Right Depth</span><span class="stat-value" id="s-right-depth">--</span></div>
        <div class="stat-row"><span class="stat-label">Right Pinch</span><span class="stat-value" id="s-right-pinch">--</span></div>
    </div>

    <div id="gesture-display" class="glass"></div>

    <div id="legend" class="glass">
        <div class="legend-title">Fingers</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff6b6b"></div>Thumb</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffa94d"></div>Index</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffd43b"></div>Middle</div>
        <div class="legend-item"><div class="legend-dot" style="background:#69db7c"></div>Ring</div>
        <div class="legend-item"><div class="legend-dot" style="background:#74c0fc"></div>Pinky</div>
    </div>

    <div id="depth-bar"><div id="depth-fill" style="height:0%"></div></div>
    <div id="depth-label">Depth</div>

    <div id="panel-controls" class="glass">
        <button class="ctrl-btn active" data-mode="skeleton">Skeleton</button>
        <button class="ctrl-btn" data-mode="model">3D Model</button>
        <button class="ctrl-btn" data-mode="both">Both</button>
        <div class="ctrl-sep"></div>
        <button class="ctrl-btn active" data-toggle="grid">Grid</button>
        <button class="ctrl-btn" data-toggle="palm">Palm</button>
        <button class="ctrl-btn" data-toggle="cam">Camera</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // ═══════════════════════════════════════════════════
        //  CONSTANTS
        // ═══════════════════════════════════════════════════
        const CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17],[0,17]
        ];

        const DRAW_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17]
        ];

        const COLORS = {
            wrist: 0xadb5bd, thumb: 0xff6b6b, index: 0xffa94d,
            middle: 0xffd43b, ring: 0x69db7c, pinky: 0x74c0fc, palm: 0x94a3b8
        };

        function jointColor(i) {
            if (i === 0) return COLORS.wrist;
            if (i <= 4)  return COLORS.thumb;
            if (i <= 8)  return COLORS.index;
            if (i <= 12) return COLORS.middle;
            if (i <= 16) return COLORS.ring;
            return COLORS.pinky;
        }

        function boneColor(a, b) {
            const hi = Math.max(a, b);
            if (hi <= 4)  return COLORS.thumb;
            if (hi <= 8)  return COLORS.index;
            if (hi <= 12) return COLORS.middle;
            if (hi <= 16) return COLORS.ring;
            if (hi <= 20) return COLORS.pinky;
            return COLORS.palm;
        }

        const JOINT_R = [
            0.014,
            0.010,0.009,0.007,0.006,
            0.010,0.008,0.006,0.005,
            0.010,0.008,0.006,0.005,
            0.009,0.007,0.006,0.005,
            0.008,0.007,0.005,0.005
        ];

        const BONE_THICKNESS = [
            0.005,0.004,0.0035,0.003,
            0.005,0.004,0.0035,0.003,
            0.005,0.004,0.0035,0.003,
            0.005,0.004,0.0035,0.003,
            0.005,0.004,0.0035,0.003,
            0.004,0.004,0.004,0.005
        ];

        const SCALE = 3.0;
        const LERP = 0.5;

        // Model strategy: 'auto' (try rigged then fallback), 'rigged', 'solid', 'off'
        const MODEL_PROFILE = 'auto';
        const ENABLE_HAND_MODEL = MODEL_PROFILE !== 'off';
        const USE_RIGGED_MODEL = MODEL_PROFILE === 'auto' || MODEL_PROFILE === 'rigged';
        const USE_SOLID_MODEL = MODEL_PROFILE === 'auto' || MODEL_PROFILE === 'solid';

        // Debug toggles for left-right mismatch issues
        const MIRROR_WORLD_X = false;
        const SWAP_HANDEDNESS = false;

        const SLOT_LEFT = 0;
        const SLOT_RIGHT = 1;
        const SLOT_LABELS = ['Left', 'Right'];

        function worldSignX() { return MIRROR_WORLD_X ? 1 : -1; }
        function mapWorldPoint(wl) {
            return new THREE.Vector3(
                worldSignX() * wl.x * SCALE,
                -wl.y * SCALE,
                -wl.z * SCALE
            );
        }
        function mapWorldDelta(a, b) {
            return new THREE.Vector3(
                worldSignX() * (b.x - a.x),
                -(b.y - a.y),
                -(b.z - a.z)
            );
        }
        function maybeSwapLabel(label) {
            if (!SWAP_HANDEDNESS) return label;
            if (label === 'Left') return 'Right';
            if (label === 'Right') return 'Left';
            return label;
        }

        // Palm mesh
        const PALM_VERTS = [0, 17, 13, 9, 5, 1];
        const PALM_TRIS  = [0,1,2, 0,2,3, 0,3,4, 0,4,5];

        // Video plane dimensions (4:3 aspect)
        const VP_W = 0.9, VP_H = 0.675, VP_Z = -0.35;

        // ═══════════════════════════════════════════════════
        //  THREE.JS SCENE
        // ═══════════════════════════════════════════════════
        const canvas = document.getElementById('three-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();

        // Gradient background
        const bgMat = new THREE.ShaderMaterial({
            uniforms: {
                colorTop:    { value: new THREE.Color(0x0f1729) },
                colorBottom: { value: new THREE.Color(0x06080d) }
            },
            vertexShader: `varying float vY; void main(){ vY=position.y; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
            fragmentShader: `uniform vec3 colorTop,colorBottom; varying float vY; void main(){ float t=smoothstep(-30.0,30.0,vY); gl_FragColor=vec4(mix(colorBottom,colorTop,t),1.0); }`,
            side: THREE.BackSide, depthWrite: false
        });
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(30,32,32), bgMat));

        const camera = new THREE.PerspectiveCamera(42, 1, 0.01, 60);
        camera.position.set(0, 0.1, 0.6);

        const orbit = new OrbitControls(camera, canvas);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.07;
        orbit.target.set(0, 0, 0);
        orbit.minDistance = 0.15;
        orbit.maxDistance = 3;

        // ── Lighting ──
        scene.add(new THREE.AmbientLight(0x2a3a5c, 0.7));
        const keyL = new THREE.DirectionalLight(0xffffff, 2.0);
        keyL.position.set(4, 8, 6);
        keyL.castShadow = true;
        keyL.shadow.mapSize.set(1024, 1024);
        keyL.shadow.bias = -0.001;
        scene.add(keyL);
        scene.add(new THREE.DirectionalLight(0x7799cc, 0.6).translateX(-5).translateY(3).translateZ(-4));
        scene.add(new THREE.PointLight(0xff7744, 0.4, 15).translateY(-4).translateZ(-8));

        // ── Grid ──
        const grid = new THREE.GridHelper(2.5, 40, 0x1a2035, 0x111828);
        grid.position.y = -0.22;
        scene.add(grid);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(5,5), new THREE.ShadowMaterial({ opacity: 0.12 }));
        ground.rotation.x = -Math.PI/2;
        ground.position.y = -0.22;
        ground.receiveShadow = true;
        scene.add(ground);

        // ═══════════════════════════════════════════════════
        //  VIDEO PLANE (Camera rectangle in 3D scene)
        // ═══════════════════════════════════════════════════
        const videoEl = document.getElementById('webcam');
        const videoTexture = new THREE.VideoTexture(videoEl);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        // Mirror for selfie view
        videoTexture.wrapS = THREE.RepeatWrapping;
        videoTexture.repeat.x = -1;
        videoTexture.offset.x = 1;

        const camGroup = new THREE.Group();
        camGroup.visible = false;

        // Frame backing
        const frameMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(VP_W + 0.025, VP_H + 0.025),
            new THREE.MeshBasicMaterial({ color: 0x111828 })
        );
        frameMesh.position.z = -0.002;
        camGroup.add(frameMesh);

        // Video surface
        const vpMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(VP_W, VP_H),
            new THREE.MeshBasicMaterial({ map: videoTexture, toneMapped: false })
        );
        camGroup.add(vpMesh);

        // Border glow
        const borderEdges = new THREE.EdgesGeometry(new THREE.PlaneGeometry(VP_W, VP_H));
        camGroup.add(new THREE.LineSegments(borderEdges,
            new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.3 })
        ));

        camGroup.position.z = VP_Z;
        scene.add(camGroup);

        // ═══════════════════════════════════════════════════
        //  HAND 3D
        // ═══════════════════════════════════════════════════
        class Hand3D {
            constructor() {
                this.group = new THREE.Group();
                this.joints = [];
                this.bones = [];
                this.pos = Array.from({ length: 21 }, () => new THREE.Vector3());
                this.tgt = Array.from({ length: 21 }, () => new THREE.Vector3());
                this.ready = false;
                this.active = false;

                for (let i = 0; i < 21; i++) {
                    const c = jointColor(i);
                    const m = new THREE.Mesh(
                        new THREE.SphereGeometry(JOINT_R[i], 24, 24),
                        new THREE.MeshStandardMaterial({
                            color: c, metalness: 0.25, roughness: 0.35,
                            emissive: c, emissiveIntensity: 0.15
                        })
                    );
                    m.castShadow = true;
                    this.group.add(m);
                    this.joints.push(m);
                }

                for (let ci = 0; ci < CONNECTIONS.length; ci++) {
                    const [a, b] = CONNECTIONS[ci];
                    const c = boneColor(a, b);
                    const geo = new THREE.CylinderGeometry(1, 1, 1, 10);
                    geo.translate(0, 0.5, 0);
                    const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
                        color: c, metalness: 0.15, roughness: 0.5,
                        emissive: c, emissiveIntensity: 0.08
                    }));
                    m.castShadow = true;
                    this.group.add(m);
                    this.bones.push({ mesh: m, a, b, thickness: BONE_THICKNESS[ci] || 0.004 });
                }

                // Palm mesh
                const palmGeo = new THREE.BufferGeometry();
                palmGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PALM_VERTS.length * 3), 3));
                palmGeo.setIndex(PALM_TRIS);
                this.palmMesh = new THREE.Mesh(palmGeo, new THREE.MeshStandardMaterial({
                    color: 0x94a3b8, metalness: 0.1, roughness: 0.6,
                    transparent: true, opacity: 0.15,
                    side: THREE.DoubleSide, depthWrite: false
                }));
                this.palmMesh.visible = false;
                this.group.add(this.palmMesh);

                this.group.visible = false;
                scene.add(this.group);
            }

            update(worldLms, normLms, opts) {
                const { showSkeleton, showPalm, camMode } = opts;

                if (!worldLms) {
                    this.active = false;
                    this.group.visible = false;
                    return null;
                }

                this.active = true;
                this.group.visible = showSkeleton;

                let estimatedDepth = 0;

                if (camMode && normLms) {
                    // ── Camera mode: position relative to video plane ──
                    const wn = normLms[0];
                    const ww = worldLms[0];

                    // Depth from apparent hand size
                    const apparentSize = Math.sqrt(
                        (normLms[0].x - normLms[9].x) ** 2 +
                        (normLms[0].y - normLms[9].y) ** 2
                    );
                    // Larger apparent size = closer = more in front
                    const depthOff = Math.max(0.03, Math.min(apparentSize * 1.8, 0.45));
                    estimatedDepth = depthOff;

                    // Wrist position on video plane (mirrored x, centered y)
                    const sx = (0.5 - wn.x) * VP_W;
                    const sy = (0.5 - wn.y) * VP_H;
                    const sz = VP_Z + depthOff;

                    for (let i = 0; i < 21; i++) {
                        const wl = worldLms[i];
                        const d = mapWorldDelta(ww, wl);
                        this.tgt[i].set(
                            sx + d.x,
                            sy + d.y,
                            sz + d.z
                        );
                    }
                } else {
                    // ── Center mode: world landmarks at origin ──
                    for (let i = 0; i < 21; i++) {
                        const wl = worldLms[i];
                        this.tgt[i].copy(mapWorldPoint(wl));
                    }
                }

                // Lerp
                const f = this.ready ? LERP : 1.0;
                for (let i = 0; i < 21; i++) {
                    this.pos[i].lerp(this.tgt[i], f);
                    this.joints[i].position.copy(this.pos[i]);
                }
                this.ready = true;

                // Bones
                const _d = new THREE.Vector3();
                const _up = new THREE.Vector3(0, 1, 0);
                for (const b of this.bones) {
                    _d.subVectors(this.pos[b.b], this.pos[b.a]);
                    const len = _d.length();
                    if (len < 1e-5) continue;
                    b.mesh.position.copy(this.pos[b.a]);
                    b.mesh.scale.set(b.thickness, len, b.thickness);
                    b.mesh.quaternion.setFromUnitVectors(_up, _d.normalize());
                }

                // Palm
                this.palmMesh.visible = showPalm && showSkeleton;
                if (showPalm) {
                    const attr = this.palmMesh.geometry.attributes.position;
                    for (let i = 0; i < PALM_VERTS.length; i++) {
                        const p = this.pos[PALM_VERTS[i]];
                        attr.setXYZ(i, p.x, p.y, p.z);
                    }
                    attr.needsUpdate = true;
                    this.palmMesh.geometry.computeVertexNormals();
                }

                return estimatedDepth;
            }
        }

        const hands3d = [new Hand3D(), new Hand3D()];

        class HandSolid {
            constructor() {
                this.group = new THREE.Group();
                this.joints = [];
                this.bones = [];
                this.pos = Array.from({ length: 21 }, () => new THREE.Vector3());
                this.tgt = Array.from({ length: 21 }, () => new THREE.Vector3());
                this.ready = false;

                const skinMat = new THREE.MeshStandardMaterial({
                    color: 0xd7b395,
                    roughness: 0.62,
                    metalness: 0.02
                });

                for (let i = 0; i < 21; i++) {
                    const m = new THREE.Mesh(
                        new THREE.SphereGeometry(JOINT_R[i] * 1.35, 18, 18),
                        skinMat.clone()
                    );
                    this.group.add(m);
                    this.joints.push(m);
                }

                for (let ci = 0; ci < CONNECTIONS.length; ci++) {
                    const [a, b] = CONNECTIONS[ci];
                    const geo = new THREE.CylinderGeometry(1, 1, 1, 14);
                    geo.translate(0, 0.5, 0);
                    const m = new THREE.Mesh(geo, skinMat.clone());
                    this.group.add(m);
                    this.bones.push({ mesh: m, a, b, thickness: (BONE_THICKNESS[ci] || 0.004) * 2.2 });
                }

                const palmGeo = new THREE.BufferGeometry();
                palmGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PALM_VERTS.length * 3), 3));
                palmGeo.setIndex(PALM_TRIS);
                this.palmMesh = new THREE.Mesh(palmGeo, new THREE.MeshStandardMaterial({
                    color: 0xd7b395,
                    roughness: 0.64,
                    metalness: 0.02,
                    transparent: true,
                    opacity: 0.92,
                    side: THREE.DoubleSide
                }));
                this.group.add(this.palmMesh);

                this.group.visible = false;
                scene.add(this.group);
            }

            update(worldLms, normLms, opts) {
                const { show, camMode } = opts;
                if (!worldLms || !show) { this.group.visible = false; return null; }
                this.group.visible = true;

                let estimatedDepth = 0;

                if (camMode && normLms) {
                    const wn = normLms[0];
                    const ww = worldLms[0];
                    const apparentSize = Math.sqrt(
                        (normLms[0].x - normLms[9].x) ** 2 +
                        (normLms[0].y - normLms[9].y) ** 2
                    );
                    const depthOff = Math.max(0.03, Math.min(apparentSize * 1.8, 0.45));
                    estimatedDepth = depthOff;

                    const sx = (0.5 - wn.x) * VP_W;
                    const sy = (0.5 - wn.y) * VP_H;
                    const sz = VP_Z + depthOff;

                    for (let i = 0; i < 21; i++) {
                        const wl = worldLms[i];
                        const d = mapWorldDelta(ww, wl);
                        this.tgt[i].set(sx + d.x, sy + d.y, sz + d.z);
                    }
                } else {
                    for (let i = 0; i < 21; i++) this.tgt[i].copy(mapWorldPoint(worldLms[i]));
                }

                const f = this.ready ? LERP : 1.0;
                for (let i = 0; i < 21; i++) {
                    this.pos[i].lerp(this.tgt[i], f);
                    this.joints[i].position.copy(this.pos[i]);
                }
                this.ready = true;

                const _d = new THREE.Vector3();
                const _up = new THREE.Vector3(0, 1, 0);
                for (const b of this.bones) {
                    _d.subVectors(this.pos[b.b], this.pos[b.a]);
                    const len = _d.length();
                    if (len < 1e-5) continue;
                    b.mesh.position.copy(this.pos[b.a]);
                    b.mesh.scale.set(b.thickness, len, b.thickness);
                    b.mesh.quaternion.setFromUnitVectors(_up, _d.normalize());
                }

                const attr = this.palmMesh.geometry.attributes.position;
                for (let i = 0; i < PALM_VERTS.length; i++) {
                    const p = this.pos[PALM_VERTS[i]];
                    attr.setXYZ(i, p.x, p.y, p.z);
                }
                attr.needsUpdate = true;
                this.palmMesh.geometry.computeVertexNormals();

                return estimatedDepth;
            }
        }

        const solidHands = [new HandSolid(), new HandSolid()];

        // ═══════════════════════════════════════════════════
        //  3D HAND MODEL (skinned mesh, bone-driven fingers)
        // ═══════════════════════════════════════════════════
        const MODEL_HAND_SIZE = 0.0745;

        // Bone aliases: dotted names from Blender + sanitized fallback names.
        const FINGER_DEFS = [
            { key: 'index1',  bones: ['finger_index.01.L',  'finger_index01L'],  fi: 5,  ti: 6,  maxA: 1.15 },
            { key: 'index2',  bones: ['finger_index.02.L',  'finger_index02L'],  fi: 6,  ti: 7,  maxA: 1.30 },
            { key: 'index3',  bones: ['finger_index.03.L',  'finger_index03L'],  fi: 7,  ti: 8,  maxA: 1.45 },
            { key: 'middle1', bones: ['finger_middle.01.L', 'finger_middle01L'], fi: 9,  ti: 10, maxA: 1.15 },
            { key: 'middle2', bones: ['finger_middle.02.L', 'finger_middle02L'], fi: 10, ti: 11, maxA: 1.30 },
            { key: 'middle3', bones: ['finger_middle.03.L', 'finger_middle03L'], fi: 11, ti: 12, maxA: 1.45 },
            { key: 'ring1',   bones: ['finger_ring.01.L',   'finger_ring01L'],   fi: 13, ti: 14, maxA: 1.15 },
            { key: 'ring2',   bones: ['finger_ring.02.L',   'finger_ring02L'],   fi: 14, ti: 15, maxA: 1.30 },
            { key: 'ring3',   bones: ['finger_ring.03.L',   'finger_ring03L'],   fi: 15, ti: 16, maxA: 1.45 },
            { key: 'pinky1',  bones: ['finger_pinky.01.L',  'finger_pinky01L'],  fi: 17, ti: 18, maxA: 1.15 },
            { key: 'pinky2',  bones: ['finger_pinky.02.L',  'finger_pinky02L'],  fi: 18, ti: 19, maxA: 1.30 },
            { key: 'pinky3',  bones: ['finger_pinky.03.L',  'finger_pinky03L'],  fi: 19, ti: 20, maxA: 1.45 },
            { key: 'thumb0',  bones: ['thumb.01.L.001',     'thumb01L001'],      fi: 0,  ti: 1,  maxA: 1.55 },
            { key: 'thumb1',  bones: ['thumb.01.L',         'thumb01L'],         fi: 1,  ti: 2,  maxA: 1.55 },
            { key: 'thumb2',  bones: ['thumb.02.L',         'thumb02L'],         fi: 2,  ti: 3,  maxA: 1.55 },
            { key: 'thumb3',  bones: ['thumb.03.L',         'thumb03L'],         fi: 3,  ti: 4,  maxA: 1.55 },
        ];

        class HandInstance {
            constructor(model) {
                this.model = model;
                this.bones = {};
                this.restQuats = {};
                this.restDirs = {};
                this.fingerBones = {};
                this.baseScale = new THREE.Vector3(1, 1, 1);
                this.baseQuat = new THREE.Quaternion();
                this.restOffsetLocal = new THREE.Vector3();
                this.handLBone = null;
                this.bindingCount = 0;
                this.valid = false;
                this._setup();
            }

            _setup() {
                let skinMesh = null;
                this.model.traverse(node => {
                    if (node.isSkinnedMesh) {
                        skinMesh = node;
                        node.frustumCulled = false;
                        node.castShadow = true;
                        node.receiveShadow = true;
                        node.material = node.material.clone();
                        node.material.side = THREE.DoubleSide;
                    }
                });

                // Get bones from skeleton (more reliable than isBone traverse)
                if (skinMesh && skinMesh.skeleton) {
                    for (const bone of skinMesh.skeleton.bones) {
                        this.bones[bone.name] = bone;
                        if (bone.name === 'hand.L' || bone.name === 'handL') this.handLBone = bone;
                    }
                    console.log('Found', skinMesh.skeleton.bones.length, 'bones');
                }

                if (!this.handLBone) { console.warn('No hand.L bone'); return; }

                this.baseScale.copy(this.model.scale);
                this.baseQuat.copy(this.model.quaternion);
                this.model.updateMatrixWorld(true);
                const restHandWorld = new THREE.Vector3();
                this.handLBone.getWorldPosition(restHandWorld);
                this.restOffsetLocal.copy(this.model.worldToLocal(restHandWorld));

                for (const def of FINGER_DEFS) {
                    const bone = def.bones.map(name => this.bones[name]).find(Boolean);
                    if (!bone) continue;
                    this.fingerBones[def.key] = bone;
                    this.restQuats[def.key] = bone.quaternion.clone();
                    const childBone = bone.children.find(c => c.isBone);
                    if (childBone) {
                        this.restDirs[def.key] = childBone.position.clone().normalize();
                    } else {
                        // Tip bone: extend in same direction as parent→self
                        this.restDirs[def.key] = bone.position.clone().normalize();
                    }
                }
                this.bindingCount = Object.keys(this.fingerBones).length;
                this.valid = this.bindingCount >= 10;
                console.log('Finger bindings:', this.bindingCount, '/', FINGER_DEFS.length);

                this.model.visible = false;
                scene.add(this.model);
                console.log('HandInstance ready, restOffsetLocal:', this.restOffsetLocal.toArray().map(v=>v.toFixed(4)));
            }

            update(worldLms, show, handednessLabel = null) {
                if (!this.handLBone) return;
                if (!worldLms || !show) { this.model.visible = false; return; }

                this.model.visible = true;
                const w = worldLms[0], m5 = worldLms[5], m9 = worldLms[9], m17 = worldLms[17];

                // Scale
                const hs = Math.sqrt((m9.x-w.x)**2+(m9.y-w.y)**2+(m9.z-w.z)**2) * SCALE;
                const s = hs / MODEL_HAND_SIZE;
                if (!isFinite(s) || s < 0.01 || s > 100) return;
                this.model.scale.copy(this.baseScale).multiplyScalar(s);

                // Rotation
                const fingersDir = mapWorldDelta(w, m9);
                if (fingersDir.lengthSq() < 1e-10) return;
                fingersDir.normalize();
                const sideDir = mapWorldDelta(m17, m5);
                if (sideDir.lengthSq() < 1e-10) return;
                sideDir.normalize();
                // Model is left-hand rig; flip lateral basis for right-hand detections
                if (handednessLabel === 'Right') sideDir.multiplyScalar(-1);
                const palmNormal = new THREE.Vector3().crossVectors(fingersDir, sideDir).normalize();
                sideDir.crossVectors(palmNormal, fingersDir).normalize();
                const targetQuat = new THREE.Quaternion().setFromRotationMatrix(
                    new THREE.Matrix4().makeBasis(fingersDir, palmNormal.clone().negate(), sideDir)
                );
                this.model.quaternion.copy(targetQuat).multiply(this.baseQuat);

                // Position: place hand.L at wrist landmark
                const wristPos = mapWorldPoint(w);
                const off = this.restOffsetLocal.clone().multiply(this.model.scale);
                off.applyQuaternion(this.model.quaternion);
                this.model.position.copy(wristPos).sub(off);

                this._driveFingers(worldLms);
            }

            _driveFingers(worldLms) {
                // Reset to rest
                for (const def of FINGER_DEFS) {
                    const b = this.fingerBones[def.key];
                    if (b && this.restQuats[def.key]) b.quaternion.copy(this.restQuats[def.key]);
                }
                this.model.updateMatrixWorld(true);

                const _pq = new THREE.Quaternion();
                const _tw = new THREE.Vector3();
                const _tl = new THREE.Vector3();
                const _rq = new THREE.Quaternion();
                const _delta = new THREE.Quaternion();
                const _restDirParent = new THREE.Vector3();
                const _axis = new THREE.Vector3(1, 0, 0);
                const _targetQ = new THREE.Quaternion();

                for (const def of FINGER_DEFS) {
                    const bone = this.fingerBones[def.key], rd = this.restDirs[def.key];
                    const restQ = this.restQuats[def.key];
                    if (!bone || !rd || !restQ || rd.lengthSq() < 1e-10) continue;
                    const lf = worldLms[def.fi], lt = worldLms[def.ti];
                    _tw.copy(mapWorldDelta(lf, lt));
                    if (_tw.lengthSq() < 1e-10) continue;
                    _tw.normalize();
                    bone.parent.getWorldQuaternion(_pq);
                    _tl.copy(_tw).applyQuaternion(_pq.clone().invert());
                    if (!isFinite(_tl.x) || !isFinite(_tl.y) || !isFinite(_tl.z)) continue;
                    _tl.normalize();
                    if (_tl.lengthSq() < 1e-10) continue;
                    _rq.copy(restQ);
                    _restDirParent.copy(rd).applyQuaternion(_rq).normalize();
                    _delta.setFromUnitVectors(_restDirParent, _tl);

                    // Clamp delta rotation to avoid skin explosions from noisy landmarks
                    const maxA = def.maxA;
                    const w = THREE.MathUtils.clamp(_delta.w, -1, 1);
                    let angle = 2 * Math.acos(w);
                    if (angle > maxA) {
                        const sinHalf = Math.sqrt(Math.max(1e-12, 1 - w * w));
                        _axis.set(_delta.x / sinHalf, _delta.y / sinHalf, _delta.z / sinHalf).normalize();
                        _delta.setFromAxisAngle(_axis, maxA);
                    }

                    _targetQ.copy(_delta).multiply(_rq);
                    bone.quaternion.slerp(_targetQ, 0.45);
                    bone.updateMatrixWorld(true);
                }
            }
        }

        const handInstances = [null, null];
        let activeModelMode = 'none';

        function setModelMode(mode) {
            activeModelMode = mode;
            const el = document.getElementById('s-model-mode');
            if (el) el.textContent = mode.toUpperCase();
            console.log('Active model mode:', mode);
        }

        function loadHandModel() {
            if (MODEL_PROFILE === 'off') {
                setModelMode('none');
                return;
            }
            if (!USE_RIGGED_MODEL) {
                setModelMode(USE_SOLID_MODEL ? 'solid' : 'none');
                return;
            }

            const loader = new GLTFLoader();
            const candidates = ['models/hand-v2.glb', 'models/hand_simple.glb', 'models/hand.glb'];

            const tryLoad = (idx) => {
                if (idx >= candidates.length) {
                    setModelMode(USE_SOLID_MODEL ? 'solid' : 'none');
                    return;
                }
                const src = candidates[idx];
                loader.load(src, (gltf) => {
                    const a = new HandInstance(gltf.scene);
                    const b = new HandInstance(SkeletonUtils.clone(gltf.scene));
                    const ok = a.valid && b.valid;
                    if (!ok) {
                        console.warn('Rigged model rejected:', src, 'bindings', a.bindingCount, b.bindingCount);
                        tryLoad(idx + 1);
                        return;
                    }
                    handInstances[0] = a;
                    handInstances[1] = b;
                    setModelMode('rigged');
                    console.log('Rigged model loaded from', src);
                }, undefined, () => {
                    tryLoad(idx + 1);
                });
            };

            tryLoad(0);
        }
        loadHandModel();

        function updateModel(worldLms, normLms, show, handIdx = 0, handednessLabel = null, camMode = false) {
            if (!ENABLE_HAND_MODEL) return;

            if (!worldLms || !show) {
                if (handInstances[handIdx]) handInstances[handIdx].update(null, false, handednessLabel);
                if (solidHands[handIdx]) solidHands[handIdx].update(null, null, { show: false, camMode: false });
                return;
            }

            if (activeModelMode === 'rigged' && handInstances[handIdx]) {
                handInstances[handIdx].update(worldLms, true, handednessLabel);
                if (solidHands[handIdx]) solidHands[handIdx].update(null, null, { show: false, camMode: false });
                return;
            }

            if (USE_SOLID_MODEL && solidHands[handIdx]) {
                solidHands[handIdx].update(worldLms, normLms, { show: true, camMode });
            }
        }

        // ═══════════════════════════════════════════════════
        //  GESTURE RECOGNITION
        // ═══════════════════════════════════════════════════
        const gestureEl = document.getElementById('gesture-display');
        let gestureTimeout = null;

        function detectGesture(wl) {
            if (!wl) return null;
            const w = wl[0];
            const tips = [4, 8, 12, 16, 20], pips = [3, 6, 10, 14, 18];
            const d = (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2);
            const ext = tips.map((t, i) => d(wl[t], w) > d(wl[pips[i]], w) * 1.12);
            const n = ext.filter(Boolean).length;
            if (n === 5) return "\u270b Open";
            if (n === 0) return "\u270a Fist";
            if (ext[0] && n === 1) return "\ud83d\udc4d Thumbs Up";
            if (!ext[0] && ext[1] && ext[2] && !ext[3] && !ext[4]) return "\u270c\ufe0f Peace";
            if (!ext[0] && ext[1] && !ext[2] && !ext[3] && !ext[4]) return "\u261d\ufe0f Point";
            if (!ext[0] && ext[1] && !ext[2] && !ext[3] && ext[4]) return "\ud83e\udd1f Rock";
            const td = d(wl[4], wl[8]), ps = d(w, wl[9]);
            if (td < ps * 0.28 && ext[2] && ext[3] && ext[4]) return "\ud83d\udc4c OK";
            return null;
        }

        function showGesture(g) {
            if (!g) {
                if (!gestureTimeout) gestureTimeout = setTimeout(() => { gestureEl.classList.remove('show'); gestureTimeout = null; }, 600);
                return;
            }
            clearTimeout(gestureTimeout); gestureTimeout = null;
            gestureEl.textContent = g;
            gestureEl.classList.add('show');
        }

        // ═══════════════════════════════════════════════════
        //  MEDIAPIPE
        // ═══════════════════════════════════════════════════
        const overlayCanvas = document.getElementById('overlay');
        const overlayCtx = overlayCanvas.getContext('2d');

        let latestFrame = { slots: [{ active: false }, { active: false }] };
        let fpsCount = 0, fpsTime = performance.now();

        function makeEmptySlot(label) {
            return { label, active: false, score: 0, world: null, norm: null, metrics: null };
        }

        function dist3(a, b) {
            return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2);
        }

        function computeMetrics(worldLms) {
            const w = worldLms[0];
            const m9 = worldLms[9];
            const ref = Math.max(1e-6, dist3(w, m9));
            const pinch = dist3(worldLms[4], worldLms[8]) / ref;
            const depth = Math.abs(w.z) * SCALE;
            return { pinch, depth };
        }

        function formatPct(v) { return (v * 100).toFixed(0) + '%'; }
        function formatDepthM(v) { return (v * 100).toFixed(0) + 'cm'; }
        function formatPinch(v) { return v.toFixed(2); }

        function updateAnalyticsPanel(slots) {
            const activeCount = slots.filter(s => s.active).length;
            document.getElementById('s-hands').textContent = activeCount;

            const left = slots[SLOT_LEFT], right = slots[SLOT_RIGHT];
            document.getElementById('s-left-conf').textContent = left.active ? formatPct(left.score) : '--';
            document.getElementById('s-left-depth').textContent = left.active ? formatDepthM(left.metrics.depth) : '--';
            document.getElementById('s-left-pinch').textContent = left.active ? formatPinch(left.metrics.pinch) : '--';

            document.getElementById('s-right-conf').textContent = right.active ? formatPct(right.score) : '--';
            document.getElementById('s-right-depth').textContent = right.active ? formatDepthM(right.metrics.depth) : '--';
            document.getElementById('s-right-pinch').textContent = right.active ? formatPinch(right.metrics.pinch) : '--';
        }

        const slotMemory = [
            { wrist: null, age: 999 },
            { wrist: null, age: 999 }
        ];

        function wristPoint(worldLms) {
            const w = worldLms[0];
            return { x: w.x, y: w.y, z: w.z };
        }

        function slotCost(det, slotIdx) {
            let cost = 0;
            const mem = slotMemory[slotIdx];

            if (mem.wrist && mem.age < 10) {
                cost += Math.min(2.8, dist3(mem.wrist, det.world[0]) * 22);
            }

            if (det.label && det.label !== SLOT_LABELS[slotIdx]) {
                cost += 0.9;
            }

            cost -= det.score * 0.08;
            return cost;
        }

        function normalizeToSlots(wls, nls, hds) {
            const slots = [makeEmptySlot(SLOT_LABELS[SLOT_LEFT]), makeEmptySlot(SLOT_LABELS[SLOT_RIGHT])];
            const detections = [];

            for (let i = 0; i < wls.length; i++) {
                detections.push({
                    world: wls[i],
                    norm: nls[i] || null,
                    label: maybeSwapLabel(hds[i]?.label || null),
                    score: hds[i]?.score ?? 0
                });
            }

            detections.sort((a, b) => b.score - a.score);
            const dets = detections.slice(0, 2);

            if (dets.length === 1) {
                const leftC = slotCost(dets[0], SLOT_LEFT);
                const rightC = slotCost(dets[0], SLOT_RIGHT);
                const idx = leftC <= rightC ? SLOT_LEFT : SLOT_RIGHT;
                const d = dets[0];
                slots[idx] = {
                    label: SLOT_LABELS[idx], active: true, score: d.score,
                    world: d.world, norm: d.norm, metrics: computeMetrics(d.world)
                };
            } else if (dets.length === 2) {
                const c01 = slotCost(dets[0], SLOT_LEFT) + slotCost(dets[1], SLOT_RIGHT);
                const c10 = slotCost(dets[1], SLOT_LEFT) + slotCost(dets[0], SLOT_RIGHT);
                const pair = c01 <= c10 ? [dets[0], dets[1]] : [dets[1], dets[0]];

                slots[SLOT_LEFT] = {
                    label: 'Left', active: true, score: pair[0].score,
                    world: pair[0].world, norm: pair[0].norm, metrics: computeMetrics(pair[0].world)
                };
                slots[SLOT_RIGHT] = {
                    label: 'Right', active: true, score: pair[1].score,
                    world: pair[1].world, norm: pair[1].norm, metrics: computeMetrics(pair[1].world)
                };
            }

            for (let i = 0; i < 2; i++) {
                if (slots[i].active) {
                    slotMemory[i].wrist = wristPoint(slots[i].world);
                    slotMemory[i].age = 0;
                } else {
                    slotMemory[i].age += 1;
                    if (slotMemory[i].age > 12) slotMemory[i].wrist = null;
                }
            }

            return slots;
        }

        document.getElementById('load-step').textContent = 'Initializing MediaPipe...';

        const mpHands = new window.Hands({
            locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
        });
        mpHands.setOptions({
            maxNumHands: 2, modelComplexity: 1,
            minDetectionConfidence: 0.7, minTrackingConfidence: 0.5
        });

        mpHands.onResults(results => {
            overlayCanvas.width = results.image.width;
            overlayCanvas.height = results.image.height;
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            if (results.multiHandLandmarks) {
                for (const lms of results.multiHandLandmarks) {
                    window.drawConnectors(overlayCtx, lms, DRAW_CONNECTIONS, { color: 'rgba(96,165,250,0.45)', lineWidth: 2 });
                    window.drawLandmarks(overlayCtx, lms, { color: 'rgba(255,255,255,0.65)', lineWidth: 1, radius: 2 });
                }
            }

            const wls = results.multiHandWorldLandmarks || [];
            const nls = results.multiHandLandmarks || [];
            const hds = results.multiHandedness || [];
            const slots = normalizeToSlots(wls, nls, hds);

            latestFrame = { slots };
            updateAnalyticsPanel(slots);

            const primary = slots[SLOT_LEFT].active ? slots[SLOT_LEFT] : (slots[SLOT_RIGHT].active ? slots[SLOT_RIGHT] : null);
            if (primary) {
                showGesture(detectGesture(primary.world));
                setPipStatus('on', 'Tracking');
            } else {
                showGesture(null);
                setPipStatus('off', 'No hand');
            }

            fpsCount++;
            const now = performance.now();
            if (now - fpsTime >= 1000) {
                document.getElementById('s-fps').textContent = fpsCount;
                fpsCount = 0; fpsTime = now;
            }
        });

        document.getElementById('load-step').textContent = 'Requesting camera...';
        const mpCam = new window.Camera(videoEl, {
            onFrame: async () => { await mpHands.send({ image: videoEl }); },
            width: 640, height: 480
        });
        mpCam.start().then(() => {
            setPipStatus('on', 'Ready');
            const ld = document.getElementById('loading');
            ld.classList.add('hidden');
            setTimeout(() => ld.remove(), 800);
        }).catch(err => {
            console.error('Camera error:', err);
            setPipStatus('err', 'Camera denied');
            document.getElementById('load-step').textContent = 'Camera access denied.';
        });

        // ═══════════════════════════════════════════════════
        //  UI CONTROLS
        // ═══════════════════════════════════════════════════
        function setPipStatus(cls, text) {
            document.getElementById('pip-dot').className = 'pip-dot ' + cls;
            document.getElementById('pip-status').textContent = text;
        }

        document.getElementById('pip-min').addEventListener('click', () => {
            document.getElementById('webcam-pip').classList.toggle('minimized');
        });
        document.getElementById('webcam-pip').addEventListener('click', function() {
            if (this.classList.contains('minimized')) this.classList.remove('minimized');
        });

        let viewMode = 'skeleton';
        let showPalm = false, showCam = false;

        document.querySelectorAll('.ctrl-btn[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.ctrl-btn[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                viewMode = btn.dataset.mode;
            });
        });

        const depthBar = document.getElementById('depth-bar');
        const depthFill = document.getElementById('depth-fill');
        const depthLabel = document.getElementById('depth-label');
        const depthRow = document.getElementById('depth-row');

        if (MODEL_PROFILE === 'off') {
            document.querySelectorAll('.ctrl-btn[data-mode="model"], .ctrl-btn[data-mode="both"]').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.45';
                btn.style.cursor = 'not-allowed';
                btn.title = 'Model mode disabled for stability';
            });
        }

        document.querySelectorAll('.ctrl-btn[data-toggle]').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                const on = btn.classList.contains('active');
                if (btn.dataset.toggle === 'grid') {
                    grid.visible = on;
                    ground.visible = on;
                } else if (btn.dataset.toggle === 'palm') {
                    showPalm = on;
                } else if (btn.dataset.toggle === 'cam') {
                    showCam = on;
                    camGroup.visible = on;
                    depthBar.style.display = on ? 'block' : 'none';
                    depthLabel.style.display = on ? 'block' : 'none';
                    if (depthRow) depthRow.style.display = on ? 'flex' : 'none';
                }
            });
        });

        // ═══════════════════════════════════════════════════
        //  RENDER LOOP
        // ═══════════════════════════════════════════════════
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();

            const showSkel = viewMode === 'skeleton' || viewMode === 'both';
            const showMdl  = ENABLE_HAND_MODEL && (viewMode === 'model' || viewMode === 'both');

            if (latestFrame && latestFrame.slots) {
                const slots = latestFrame.slots;
                let depthShown = false;

                for (let i = 0; i < 2; i++) {
                    const slot = slots[i];
                    if (slot && slot.active) {
                        const depth = hands3d[i].update(slot.world, slot.norm, {
                            showSkeleton: showSkel, showPalm, camMode: showCam
                        });
                        updateModel(slot.world, slot.norm, showMdl, i, slot.label, showCam);

                        if (!depthShown && showCam && depth !== null) {
                            const pct = Math.min(100, Math.max(0, (depth / 0.45) * 100));
                            depthFill.style.height = pct + '%';
                            depthShown = true;
                        }
                    } else {
                        hands3d[i].update(null, null, { showSkeleton: false, showPalm: false, camMode: false });
                        updateModel(null, null, false, i, null, false);
                    }
                }

                if (!depthShown) depthFill.style.height = '0%';
            }

            // Resize
            const w = window.innerWidth, h = window.innerHeight;
            const dpr = renderer.getPixelRatio();
            if (canvas.width !== Math.floor(w * dpr) || canvas.height !== Math.floor(h * dpr)) {
                renderer.setSize(w, h, false);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
