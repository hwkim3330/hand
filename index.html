<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Tracking</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        #container { display: flex; height: 100vh; }
        #video-section {
            width: 35%;
            min-width: 280px;
            position: relative;
            background: #111;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #webcam {
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }
        #three-section {
            flex: 1;
            position: relative;
            background: #0d1117;
        }
        #three-canvas { width: 100%; height: 100%; display: block; }
        #status {
            position: absolute;
            top: 12px; left: 12px;
            background: rgba(0,0,0,0.65);
            backdrop-filter: blur(8px);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
            display: flex; align-items: center; gap: 8px;
        }
        .dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .dot.green { background: #4ade80; box-shadow: 0 0 6px #4ade80; }
        .dot.yellow { background: #fbbf24; box-shadow: 0 0 6px #fbbf24; }
        .dot.red { background: #f87171; box-shadow: 0 0 6px #f87171; }
        #info {
            position: absolute;
            top: 12px; left: 12px;
            background: rgba(0,0,0,0.55);
            backdrop-filter: blur(8px);
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.7;
            z-index: 10;
        }
        #info span { color: #60a5fa; font-weight: 600; }
        #controls {
            position: absolute;
            bottom: 16px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 8px;
            z-index: 10;
        }
        .btn {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: #ccc;
            padding: 7px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            user-select: none;
        }
        .btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
        .btn.active {
            background: rgba(96,165,250,0.2);
            border-color: rgba(96,165,250,0.5);
            color: #60a5fa;
        }
        #title {
            position: absolute;
            bottom: 16px; left: 12px;
            font-size: 11px;
            color: #555;
            z-index: 10;
        }
        #loading {
            position: fixed;
            inset: 0;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.6s;
        }
        .spinner {
            width: 44px; height: 44px;
            border: 3px solid rgba(255,255,255,0.08);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading p { margin-top: 18px; color: #666; font-size: 14px; }
        #gesture {
            position: absolute;
            top: 60px; left: 12px;
            background: rgba(96,165,250,0.15);
            border: 1px solid rgba(96,165,250,0.3);
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 10;
            display: none;
        }
        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #video-section { width: 100%; height: 40%; min-width: auto; }
            #three-section { height: 60%; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading Hand Tracking...</p>
    </div>

    <div id="container">
        <div id="video-section">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="overlay"></canvas>
            <div id="status">
                <div class="dot yellow"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
        <div id="three-section">
            <canvas id="three-canvas"></canvas>
            <div id="info">
                <div>FPS: <span id="fps">--</span></div>
                <div>Hands: <span id="hand-count">0</span></div>
                <div>Confidence: <span id="confidence">--</span></div>
            </div>
            <div id="gesture"></div>
            <div id="controls">
                <button class="btn active" data-mode="skeleton">Skeleton</button>
                <button class="btn" data-mode="mesh">3D Model</button>
                <button class="btn active" data-toggle="grid">Grid</button>
            </div>
            <div id="title">MediaPipe + Three.js Hand Tracking</div>
        </div>
    </div>

    <!-- MediaPipe Hands (classic API) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // ============================================================
        //  CONSTANTS
        // ============================================================
        const CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],         // thumb
            [0,5],[5,6],[6,7],[7,8],         // index
            [0,9],[9,10],[10,11],[11,12],    // middle
            [0,13],[13,14],[14,15],[15,16],  // ring
            [0,17],[17,18],[18,19],[19,20],  // pinky
            [5,9],[9,13],[13,17],[0,17]      // palm
        ];

        const MP_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17]
        ];

        const FINGER_COLORS = [
            0xffffff,                                           // 0: wrist
            0xff6b6b, 0xff6b6b, 0xff6b6b, 0xff6b6b,          // 1-4: thumb
            0xffa94d, 0xffa94d, 0xffa94d, 0xffa94d,          // 5-8: index
            0xffd43b, 0xffd43b, 0xffd43b, 0xffd43b,          // 9-12: middle
            0x69db7c, 0x69db7c, 0x69db7c, 0x69db7c,          // 13-16: ring
            0x74c0fc, 0x74c0fc, 0x74c0fc, 0x74c0fc           // 17-20: pinky
        ];

        const JOINT_RADIUS = [
            0.013,
            0.009, 0.008, 0.007, 0.006,
            0.009, 0.007, 0.006, 0.005,
            0.009, 0.007, 0.006, 0.005,
            0.008, 0.007, 0.006, 0.005,
            0.007, 0.006, 0.005, 0.005
        ];

        const SCALE = 3.0;
        const LERP_FACTOR = 0.45;

        // ============================================================
        //  THREE.JS SETUP
        // ============================================================
        const canvas = document.getElementById('three-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d1117);
        scene.fog = new THREE.FogExp2(0x0d1117, 1.2);

        const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 50);
        camera.position.set(0, 0.12, 0.55);

        const orbitControls = new OrbitControls(camera, canvas);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.08;
        orbitControls.target.set(0, 0, 0);
        orbitControls.minDistance = 0.1;
        orbitControls.maxDistance = 3;

        // Lights
        scene.add(new THREE.AmbientLight(0x334466, 0.6));

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.8);
        keyLight.position.set(3, 8, 5);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.set(1024, 1024);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0x6688cc, 0.5);
        fillLight.position.set(-4, 2, -3);
        scene.add(fillLight);

        const rimLight = new THREE.PointLight(0xff8855, 0.4, 10);
        rimLight.position.set(0, -3, -5);
        scene.add(rimLight);

        // Grid
        const grid = new THREE.GridHelper(2, 30, 0x222233, 0x181825);
        grid.position.y = -0.2;
        scene.add(grid);

        // Ground plane (for shadow)
        const groundGeo = new THREE.PlaneGeometry(4, 4);
        const groundMat = new THREE.ShadowMaterial({ opacity: 0.15 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ============================================================
        //  HAND 3D SKELETON
        // ============================================================
        class Hand3D {
            constructor() {
                this.group = new THREE.Group();
                this.joints = [];
                this.bones = [];
                this.positions = new Array(21).fill(null).map(() => new THREE.Vector3());
                this.targets = new Array(21).fill(null).map(() => new THREE.Vector3());
                this.hasData = false;
                this.active = false;

                // Joints
                for (let i = 0; i < 21; i++) {
                    const color = FINGER_COLORS[i];
                    const geo = new THREE.SphereGeometry(JOINT_RADIUS[i], 20, 20);
                    const mat = new THREE.MeshStandardMaterial({
                        color,
                        metalness: 0.35,
                        roughness: 0.3,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = true;
                    this.group.add(mesh);
                    this.joints.push(mesh);
                }

                // Bones (cylinders)
                for (const [a, b] of CONNECTIONS) {
                    const color = this._boneColor(a, b);
                    const geo = new THREE.CylinderGeometry(1, 1, 1, 8);
                    geo.translate(0, 0.5, 0);
                    const mat = new THREE.MeshStandardMaterial({
                        color,
                        metalness: 0.2,
                        roughness: 0.45,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = true;
                    this.group.add(mesh);
                    this.bones.push({ mesh, a, b });
                }

                this.group.visible = false;
                scene.add(this.group);
            }

            _boneColor(a, b) {
                const hi = Math.max(a, b);
                if (hi <= 4) return 0xff6b6b;
                if (hi <= 8) return 0xffa94d;
                if (hi <= 12) return 0xffd43b;
                if (hi <= 16) return 0x69db7c;
                if (hi <= 20) return 0x74c0fc;
                return 0x888888;
            }

            update(worldLandmarks) {
                if (!worldLandmarks) {
                    this.active = false;
                    this.group.visible = false;
                    return;
                }

                this.active = true;
                this.group.visible = true;

                // Set targets from landmarks
                for (let i = 0; i < 21; i++) {
                    const lm = worldLandmarks[i];
                    this.targets[i].set(
                        -lm.x * SCALE,
                        -lm.y * SCALE,
                        -lm.z * SCALE
                    );
                }

                // Lerp positions
                const factor = this.hasData ? LERP_FACTOR : 1.0;
                for (let i = 0; i < 21; i++) {
                    this.positions[i].lerp(this.targets[i], factor);
                    this.joints[i].position.copy(this.positions[i]);
                }
                this.hasData = true;

                // Update bone cylinders
                const _dir = new THREE.Vector3();
                const _up = new THREE.Vector3(0, 1, 0);
                for (const bone of this.bones) {
                    const from = this.positions[bone.a];
                    const to = this.positions[bone.b];
                    _dir.subVectors(to, from);
                    const len = _dir.length();
                    if (len < 0.0001) continue;

                    const radius = 0.003;
                    bone.mesh.position.copy(from);
                    bone.mesh.scale.set(radius, len, radius);
                    bone.mesh.quaternion.setFromUnitVectors(_up, _dir.normalize());
                }
            }

            setVisible(v) {
                if (this.active) this.group.visible = v;
            }
        }

        const hands3d = [new Hand3D(), new Hand3D()];

        // ============================================================
        //  FBX MODEL
        // ============================================================
        let fbxModel = null;
        let fbxSkeleton = null;
        let fbxBoneMap = {};
        let showModel = false;

        const BONE_FINGER_MAP = {
            thumb:  { indices: [[0,1],[1,2],[2,3],[3,4]], patterns: [/thumb/i] },
            index:  { indices: [[5,6],[6,7],[7,8]],       patterns: [/index/i] },
            middle: { indices: [[9,10],[10,11],[11,12]],   patterns: [/middle|mid/i] },
            ring:   { indices: [[13,14],[14,15],[15,16]],  patterns: [/ring/i] },
            pinky:  { indices: [[17,18],[18,19],[19,20]],  patterns: [/pinky|little/i] }
        };

        function loadFBXModel() {
            const loader = new FBXLoader();
            loader.load('models/rigged_hand.fbx',
                (object) => {
                    object.scale.setScalar(0.003);
                    object.visible = false;

                    const bones = [];
                    object.traverse((child) => {
                        if (child.isBone) {
                            bones.push(child);
                            fbxBoneMap[child.name.toLowerCase()] = child;
                        }
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    console.log('FBX bones:', bones.map(b => b.name));
                    fbxModel = object;
                    fbxSkeleton = bones;
                    scene.add(fbxModel);
                },
                undefined,
                (err) => console.warn('FBX load error (non-critical):', err)
            );
        }

        loadFBXModel();

        function updateFBXFromLandmarks(worldLandmarks) {
            if (!fbxModel || !worldLandmarks) {
                if (fbxModel) fbxModel.visible = false;
                return;
            }
            if (!showModel) {
                fbxModel.visible = false;
                return;
            }

            fbxModel.visible = true;

            // Position model at wrist
            const wrist = worldLandmarks[0];
            const middle_mcp = worldLandmarks[9];
            fbxModel.position.set(
                -wrist.x * SCALE,
                -wrist.y * SCALE,
                -wrist.z * SCALE
            );

            // Orient model: palm direction
            const palmDir = new THREE.Vector3(
                -(middle_mcp.x - wrist.x),
                -(middle_mcp.y - wrist.y),
                -(middle_mcp.z - wrist.z)
            ).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const quat = new THREE.Quaternion().setFromUnitVectors(up, palmDir);
            fbxModel.quaternion.copy(quat);
        }

        // ============================================================
        //  GESTURE RECOGNITION
        // ============================================================
        function detectGesture(landmarks) {
            if (!landmarks) return null;

            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20];
            const pips = [3, 6, 10, 14, 18];

            // Check if fingers are extended
            const extended = tips.map((tip, i) => {
                const pip = pips[i];
                const tipDist = dist3d(landmarks[tip], wrist);
                const pipDist = dist3d(landmarks[pip], wrist);
                return tipDist > pipDist * 1.1;
            });

            const extCount = extended.filter(Boolean).length;

            // Open palm
            if (extCount === 5) return "\u270B Open";
            // Fist
            if (extCount === 0) return "\u270a Fist";
            // Thumbs up
            if (extended[0] && extCount === 1) return "\ud83d\udc4d Thumbs Up";
            // Peace
            if (!extended[0] && extended[1] && extended[2] && !extended[3] && !extended[4])
                return "\u270c\ufe0f Peace";
            // Point
            if (!extended[0] && extended[1] && !extended[2] && !extended[3] && !extended[4])
                return "\u261d\ufe0f Point";
            // Rock
            if (!extended[0] && extended[1] && !extended[2] && !extended[3] && extended[4])
                return "\ud83e\udd1f Rock";
            // OK
            const thumbIndexDist = dist3d(landmarks[4], landmarks[8]);
            const palmSize = dist3d(landmarks[0], landmarks[9]);
            if (thumbIndexDist < palmSize * 0.3 && extended[2] && extended[3] && extended[4])
                return "\ud83d\udc4c OK";

            return null;
        }

        function dist3d(a, b) {
            return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2);
        }

        // ============================================================
        //  MEDIAPIPE SETUP
        // ============================================================
        const videoEl = document.getElementById('webcam');
        const overlayCanvas = document.getElementById('overlay');
        const overlayCtx = overlayCanvas.getContext('2d');
        const gestureEl = document.getElementById('gesture');

        let latestResults = null;
        let frameCount = 0;
        let lastFpsTime = performance.now();

        const mpHands = new window.Hands({
            locateFile: (file) =>
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
        });

        mpHands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        mpHands.onResults((results) => {
            latestResults = results;

            // Draw overlay
            overlayCanvas.width = results.image.width;
            overlayCanvas.height = results.image.height;
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            if (results.multiHandLandmarks) {
                for (const lms of results.multiHandLandmarks) {
                    window.drawConnectors(overlayCtx, lms, MP_CONNECTIONS, {
                        color: 'rgba(100,180,255,0.5)', lineWidth: 2
                    });
                    window.drawLandmarks(overlayCtx, lms, {
                        color: 'rgba(255,255,255,0.7)', lineWidth: 1, radius: 3
                    });
                }
            }

            // Status
            const numHands = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            document.getElementById('hand-count').textContent = numHands;

            if (numHands > 0) {
                const conf = (results.multiHandedness[0].score * 100).toFixed(0);
                document.getElementById('confidence').textContent = conf + '%';
                setStatus('green', `Tracking ${numHands} hand${numHands > 1 ? 's' : ''}`);
            } else {
                document.getElementById('confidence').textContent = '--';
                setStatus('yellow', 'No hand detected');
            }

            // Gesture
            if (results.multiHandWorldLandmarks && results.multiHandWorldLandmarks.length > 0) {
                const g = detectGesture(results.multiHandWorldLandmarks[0]);
                if (g) {
                    gestureEl.textContent = g;
                    gestureEl.style.display = 'block';
                } else {
                    gestureEl.style.display = 'none';
                }
            } else {
                gestureEl.style.display = 'none';
            }

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }
        });

        // Start camera
        const mpCamera = new window.Camera(videoEl, {
            onFrame: async () => {
                await mpHands.send({ image: videoEl });
            },
            width: 640,
            height: 480
        });

        mpCamera.start().then(() => {
            setStatus('green', 'Camera ready');
            hideLoading();
        }).catch((err) => {
            console.error('Camera error:', err);
            setStatus('red', 'Camera access denied');
            hideLoading();
        });

        // ============================================================
        //  UI HELPERS
        // ============================================================
        function setStatus(color, text) {
            document.querySelector('#status .dot').className = `dot ${color}`;
            document.getElementById('status-text').textContent = text;
        }

        function hideLoading() {
            const el = document.getElementById('loading');
            el.style.opacity = '0';
            setTimeout(() => el.style.display = 'none', 600);
        }

        // Controls
        let viewMode = 'skeleton';

        document.querySelectorAll('#controls .btn[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#controls .btn[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                viewMode = btn.dataset.mode;
                showModel = viewMode === 'mesh';
            });
        });

        document.querySelector('#controls .btn[data-toggle="grid"]').addEventListener('click', function() {
            this.classList.toggle('active');
            grid.visible = this.classList.contains('active');
            ground.visible = grid.visible;
        });

        // ============================================================
        //  ANIMATION LOOP
        // ============================================================
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();

            // Update 3D hands
            if (latestResults && latestResults.multiHandWorldLandmarks) {
                for (let i = 0; i < 2; i++) {
                    if (i < latestResults.multiHandWorldLandmarks.length) {
                        const wl = latestResults.multiHandWorldLandmarks[i];
                        hands3d[i].update(wl);
                        hands3d[i].setVisible(viewMode === 'skeleton');

                        if (i === 0) updateFBXFromLandmarks(wl);
                    } else {
                        hands3d[i].update(null);
                    }
                }
            } else {
                hands3d[0].update(null);
                hands3d[1].update(null);
                if (fbxModel) fbxModel.visible = false;
            }

            // Resize
            const rect = canvas.parentElement.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            if (canvas.width !== w * devicePixelRatio || canvas.height !== h * devicePixelRatio) {
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
